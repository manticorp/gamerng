var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(f){var h=0;return function(){return h<f.length?{done:!1,value:f[h++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(f,h,l){if(f==Array.prototype||f==Object.prototype)return f;f[h]=l.value;return f};$jscomp.getGlobal=function(f){f=["object"==typeof globalThis&&globalThis,f,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var h=0;h<f.length;++h){var l=f[h];if(l&&l.Math==Math)return l}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(f,h,l){if(!l||null!=f){l=$jscomp.propertyToPolyfillSymbol[h];if(null==l)return f[h];l=f[l];return void 0!==l?l:f[h]}};
$jscomp.polyfill=function(f,h,l,m){h&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(f,h,l,m):$jscomp.polyfillUnisolated(f,h,l,m))};$jscomp.polyfillUnisolated=function(f,h,l,m){l=$jscomp.global;f=f.split(".");for(m=0;m<f.length-1;m++){var n=f[m];if(!(n in l))return;l=l[n]}f=f[f.length-1];m=l[f];h=h(m);h!=m&&null!=h&&$jscomp.defineProperty(l,f,{configurable:!0,writable:!0,value:h})};
$jscomp.polyfillIsolated=function(f,h,l,m){var n=f.split(".");f=1===n.length;m=n[0];m=!f&&m in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var z=0;z<n.length-1;z++){var g=n[z];if(!(g in m))return;m=m[g]}n=n[n.length-1];l=$jscomp.IS_SYMBOL_NATIVE&&"es6"===l?m[n]:null;h=h(l);null!=h&&(f?$jscomp.defineProperty($jscomp.polyfills,n,{configurable:!0,writable:!0,value:h}):h!==l&&(void 0===$jscomp.propertyToPolyfillSymbol[n]&&(l=1E9*Math.random()>>>0,$jscomp.propertyToPolyfillSymbol[n]=$jscomp.IS_SYMBOL_NATIVE?
$jscomp.global.Symbol(n):$jscomp.POLYFILL_PREFIX+l+"$"+n),$jscomp.defineProperty(m,$jscomp.propertyToPolyfillSymbol[n],{configurable:!0,writable:!0,value:h})))};$jscomp.initSymbol=function(){};$jscomp.iteratorPrototype=function(f){f={next:f};f[Symbol.iterator]=function(){return this};return f};$jscomp.owns=function(f,h){return Object.prototype.hasOwnProperty.call(f,h)};
$jscomp.polyfill("Object.entries",function(f){return f?f:function(h){var l=[],m;for(m in h)$jscomp.owns(h,m)&&l.push([m,h[m]]);return l}},"es8","es3");$jscomp.checkStringArgs=function(f,h,l){if(null==f)throw new TypeError("The 'this' value for String.prototype."+l+" must not be null or undefined");if(h instanceof RegExp)throw new TypeError("First argument to String.prototype."+l+" must not be a regular expression");return f+""};
$jscomp.stringPadding=function(f,h){f=void 0!==f?String(f):" ";return 0<h&&f?f.repeat(Math.ceil(h/f.length)).substring(0,h):""};$jscomp.polyfill("String.prototype.padEnd",function(f){return f?f:function(h,l){var m=$jscomp.checkStringArgs(this,null,"padStart");return m+$jscomp.stringPadding(l,h-m.length)}},"es8","es3");
var GameRng=function(){function f(a,b,c){if("function"==typeof a?a===b:a.has(b))return 3>arguments.length?b:c;throw new TypeError("Private element is not present on this object");}function h(a,b){return a.get(f(a,b))}function l(a,b,c){if(b.has(a))throw new TypeError("Cannot initialize the same private elements twice on an object");b.set(a,c)}function m(a,b,c){return a.set(f(a,b),c),c}function n(a,b,c){a:{var d=b;if("object"==typeof d&&d){var e=d[Symbol.toPrimitive];if(void 0!==e){d=e.call(d,"string");
if("object"!=typeof d)break a;throw new TypeError("@@toPrimitive must return a primitive value.");}d=String(d)}}return(b="symbol"==typeof d?d:d+"")in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}function z(a){return"number"===typeof a||!isNaN(parseFloat(a))&&isFinite(a)}function g(a){if(Array.isArray(a))return new N(a);if("object"===typeof a){a=Object.entries(a);if(0===a.length)throw Error("Empty object provided");const [b,c]=a[0];return g(c).varname(b)}return new O(a)}
function P(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"";const b=1E3*Date.now();Q===b?F++:F=0;const c=(b+F).toString(16).replace(/\./g,"").padEnd(14,"0");Q=b;return`${a}${c}`}function V(a){if(Array.isArray(a))return a.reduce((e,k)=>e+k,0);for(var b=arguments.length,c=Array(1<b?b-1:0),d=1;d<b;d++)c[d-1]=arguments[d];return c.reduce((e,k)=>e+k,0)}function G(a){return"number"===typeof a||!isNaN(parseFloat(a))&&isFinite(a)}const t=function(a){let b=1<arguments.length&&void 0!==arguments[1]?
arguments[1]:"Assertion failed";if(!a)throw new W(b);};class W extends Error{}var H=new WeakMap;class N{constructor(a){let b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"numbers";l(this,H,[]);n(this,"name","numbers");this.numbers=a;this.name=b}get numbers(){return h(H,this)}set numbers(a){for(const b of a)t("number"===typeof b,`Non-number passed to validator ${b}`);m(H,this,a)}all(a){this.numbers=a;return this}validate(a){return Array.isArray(a)?this.all(a):new O(a)}varname(a){this.name=
a;return this}sum(){return this.numbers.reduce((a,b)=>a+b,0)}sumcloseto(a){let b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1E-4,c=2<arguments.length?arguments[2]:void 0;t(Math.abs(this.sum()-a)<b,null!=c?c:`Expected sum of ${this.name} to be within ${b} of ${a}, got ${this.sum()}`);return this}sumto(a,b){t(this.sum()===a,null!=b?b:`Expected sum of ${this.name} to be equal to ${a}, got ${this.sum()}`);return this}sumtolt(a,b){t(this.sum()<a,null!=b?b:`Expected sum of ${this.name} to be less than ${a}, got ${this.sum()}`);
return this}sumtogt(a,b){t(this.sum()>a,null!=b?b:`Expected sum of ${this.name} to be greater than ${a}, got ${this.sum()}`);return this}sumtolteq(a,b){t(this.sum()<=a,null!=b?b:`Expected sum of ${this.name} to be less than or equal to ${a}, got ${this.sum()}`);return this}sumtogteq(a,b){t(this.sum()>=a,null!=b?b:`Expected sum of ${this.name} to be greater than or equal to ${a}, got ${this.sum()}`);return this}int(a){this.numbers.forEach(b=>g(b).int(null!=a?a:`Expected every component of ${this.name} to be an integer, got ${b}`));
return this}positive(a){this.numbers.forEach(b=>g(b).positive(null!=a?a:`Expected every component of ${this.name} to be postiive, got ${b}`));return this}negative(a){this.numbers.forEach(b=>g(b).negative(null!=a?a:`Expected every component of ${this.name} to be negative, got ${b}`));return this}between(a,b,c){this.numbers.forEach(d=>g(d).between(a,b,null!=c?c:`Expected every component of ${this.name} to be between ${a} and ${b}, got ${d}`));return this}betweenEq(a,b,c){this.numbers.forEach(d=>g(d).betweenEq(a,
b,null!=c?c:`Expected every component of ${this.name} to be between or equal to ${a} and ${b}, got ${d}`));return this}gt(a,b){this.numbers.forEach(c=>g(c).gt(a,null!=b?b:`Expected every component of ${this.name} to be > ${a}, got ${c}`));return this}gteq(a,b){this.numbers.forEach(c=>g(c).gteq(a,null!=b?b:`Expected every component of ${this.name} to be >= ${a}, got ${c}`));return this}lt(a,b){this.numbers.forEach(c=>g(c).lt(a,null!=b?b:`Expected every component of ${this.name} to be < ${a}, got ${c}`));
return this}lteq(a,b){this.numbers.forEach(c=>g(c).lteq(a,null!=b?b:`Expected every component of ${this.name} to be <= ${a}, got ${c}`));return this}}var I=new WeakMap;class O{constructor(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"number";l(this,I,void 0);n(this,"name","number");"string"===typeof a&&(a=parseFloat(a));this.number=a;this.name=b}get number(){return h(I,this)}set number(a){t(z(a),`Non-number passed to validator ${a}`);
"string"===typeof a&&(a=parseFloat("number"));m(I,this,a)}all(a,b){return new N(a,null!=b?b:this.name)}assertNumber(a){t("undefined"!==typeof a,"No number passed to validator.");return!0}varname(a){this.name=a;return this}validate(a){if(Array.isArray(a))return this.all(a);this.number=a;return this}integer(a){return this.int(a)}int(a){this.assertNumber(this.number)&&t(Number.isInteger(this.number),null!=a?a:`Expected ${this.name} to be an integer, got ${this.number}`);return this}positive(a){return this.gt(0,
null!=a?a:`Expected ${this.name} to be positive, got ${this.number}`)}negative(a){return this.lt(0,null!=a?a:`Expected ${this.name} to be negative, got ${this.number}`)}between(a,b,c){this.assertNumber(this.number)&&t(this.number>a&&this.number<b,null!=c?c:`Expected ${this.name} to be between ${a} and ${b}, got ${this.number}`);return this}betweenEq(a,b,c){this.assertNumber(this.number)&&t(this.number>=a&&this.number<=b,null!=c?c:`Expected ${this.name} to be between or equal to ${a} and ${b}, got ${this.number}`);
return this}gt(a,b){this.assertNumber(this.number)&&t(this.number>a,null!=b?b:`Expected ${this.name} to be greater than ${a}, got ${this.number}`);return this}gteq(a,b){this.assertNumber(this.number)&&t(this.number>=a,null!=b?b:`Expected ${this.name} to be greater than or equal to ${a}, got ${this.number}`);return this}lt(a,b){this.assertNumber(this.number)&&t(this.number<a,null!=b?b:`Expected ${this.name} to be less than ${a}, got ${this.number}`);return this}lteq(a,b){this.assertNumber(this.number)&&
t(this.number<=a,null!=b?b:`Expected ${this.name} to be less than or equal to ${a}, got ${this.number}`);return this}}class R extends Error{}class X extends Error{}var w=new WeakMap;class Y{constructor(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[],b=1<arguments.length?arguments[1]:void 0;n(this,"rng",void 0);l(this,w,[]);this.entries=a;this.rng=b?b:new C}copyArray(a){return Array.from(a)}setEntries(a){this.entries=a;return this}getEntries(){return h(w,this)}set entries(a){m(w,
this,this.copyArray(a))}get entries(){return h(w,this)}get length(){return h(w,this).length}setRng(a){this.rng=a;return this}getRng(){return this.rng}add(a){h(w,this).push(a)}empty(){m(w,this,[]);return this}isEmpty(){return 0>=this.length}draw(){if(0===this.length)throw new R("No more elements left to draw from in pool.");if(1===this.length)return h(w,this).splice(0,1)[0];const a=this.rng.randInt(0,h(w,this).length-1);return h(w,this).splice(a,1)[0]}drawMany(a){if(0>a)throw Error("Cannot draw < 0 elements from pool");
if(0===this.length&&0<a)throw new R("No more elements left to draw from in pool.");if(this.length<a)throw new X(`Tried to draw ${a} elements from pool with only ${this.length} entries.`);const b=[];for(let c=0;c<a;c++){const d=this.rng.randInt(0,h(w,this).length-1);b.push(h(w,this).splice(d,1)[0])}return b}}class Z{constructor(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;n(this,"size",void 0);n(this,"elements",[]);Array.isArray(a)?(this.elements=a,this.size=this.elements.length):
this.size=a}get length(){return this.elements.length}push(a){this.elements.push(a);if(this.elements.length>this.size)return this.pop()}pop(){return this.elements.pop()}full(){return this.length>=this.size}empty(){this.elements=[]}get(a){return this.elements[a]}allSame(){return 0<this.length?this.elements.every(a=>a===this.elements[0]):!0}}class aa extends Error{}class J extends Z{constructor(){let a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:2;super(0<arguments.length&&void 0!==arguments[0]?
arguments[0]:1);n(this,"minsequencelength",2);n(this,"errormessage","Loop detected in input data. Randomness source not random?");if(1E4<this.size)throw Error("Cannot detect loops for more than 10000 elements");this.minsequencelength=a}push(a){this.detectLoop();this.elements.push(a);if(this.elements.length>this.size)return this.pop()}detectLoop(a){this.full()&&(this.allSame()&&this.loopDetected(a),this.hasRepeatingSequence(this.elements,this.minsequencelength)&&this.loopDetected(a))}loopDetected(a){throw new aa(null!=
a?a:this.errormessage);}hasRepeatingSequence(a,b){for(let c=0;c<a.length;c++)for(let d=c+1;d<a.length;d++){let e=0;for(;d+e<a.length&&a[c+e]===a[d+e];)if(e++,e>b)return!0}return!1}}const ba=/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;class x{constructor(a,b){let c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,d=3<arguments.length?arguments[3]:void 0,
e=4<arguments.length?arguments[4]:void 0;n(this,"major",0);n(this,"minor",0);n(this,"patch",0);n(this,"build",void 0);n(this,"presplit",[]);if(a instanceof x)this.major=a.major,this.minor=a.minor,this.patch=a.patch,this.presplit=a.presplit,this.build=a.build;else{if("object"===typeof a){({major:a=0,minor:b,patch:c=0,prerelease:d,build:e}=a);this.major="string"===typeof a?parseInt(a):a;let k;this.minor=null!=(k="string"===typeof b?parseInt(b):b)?k:0===this.major?1:0;this.patch="string"===typeof c?
parseInt(c):c}else{if("string"===typeof a&&"undefined"===typeof b)({major:a,minor:b,patch:c,prerelease:d,build:e}=x.parse(a)),this.major=a,this.minor=b;else{a="string"===typeof a?parseInt(a):a;b="string"===typeof b?parseInt(b):b;c="string"===typeof c?parseInt(c):c;this.major=a;let k;this.minor=null!=(k=b)?k:0===a?1:0}this.patch=c}this.prerelease=d;this.build=e}g({major:this.major}).gteq(0).integer();g({minor:this.minor}).gteq(0).integer();g({patch:this.patch}).gteq(0).integer()}get prerelease(){if(0!==
this.presplit.length)return this.presplit.join(".")}set prerelease(a){this.presplit=this.splitPre(a)}splitPre(a){if("undefined"===typeof a||""===a)return[];a=`${a}`.trim();return a.split(".").map(b=>{if(z(b)){const c=+b;if(0<=c&&c<Number.MAX_SAFE_INTEGER)return c}return b})}static parse(a){a=ba.exec(a);if(null===a)throw Error("Invalid semver string.");let [b,c,d,e,k]=Array.from(a).slice(1);b=parseInt(b);c=parseInt(c);d=parseInt(d);return new x({major:b,minor:c,patch:d,prerelease:e,build:k})}plain(){return{major:this.major,
minor:this.minor,patch:this.patch,prerelease:this.prerelease,build:this.build}}toString(){let a=`${this.major}.${this.minor}.${this.patch}`;0<this.presplit.length&&(a=`${a}-${this.presplit.join(".")}`);"undefined"!==typeof this.build&&(a=`${a}+${this.build}`);return a}comparePrerelease(a){a=new x(a);if(this.presplit.length&&!a.presplit.length)return-1;if(!this.presplit.length&&a.presplit.length)return 1;if(!this.presplit.length&&!a.presplit.length)return 0;var b=0;do{var c=this.presplit[b],d=a.presplit[b];
if(void 0===c&&void 0===d)break;else{if(void 0===d)return 1;if(void 0===c)return-1;if(c!==d)return a=c,b=z(a),c=z(d),b&&c&&(a=+a,d=+d),a===d?0:b&&!c?-1:c&&!b?1:a<d?-1:1}}while(++b);return 0}gt(a){a=new x(a);return 0<this.presplit.length&&0<a.presplit.length?this.sameVer(a)?0>=this.comparePrerelease(a)?!1:!0:!1:this.major>a.major||this.minor>a.minor||this.patch>a.patch||0===this.presplit.length&&0<a.presplit.length?!0:!1}gteq(a){a=new x(a);return this.gt(a)||this.eq(a)}sameVer(a){a=new x(a);return this.major===
a.major&&this.minor===a.minor&&this.patch===a.patch}eq(a){a=new x(a);return this.sameVer(a)&&this.samePre(a)}samePre(a){a=new x(a);return this.prerelease===a.prerelease}same(a){const b=new x(a);return this.eq(a)&&this.build===b.build}lt(a){a=new x(a);return 0<this.presplit.length&&0<a.presplit.length?this.sameVer(a)?0<=this.comparePrerelease(a)?!1:!0:!1:this.major<a.major||this.minor<a.minor||this.patch<a.patch?!0:!1}lteq(a){return this.lt(a)||this.eq(a)}}const S=/^ *([+-]? *[0-9_]*) *[dD] *([0-9_]+) *([+-]? *[0-9_.]*) *$/,
K={},y={};let F=0,Q=0,T=Date.now(),L=0;class U extends Error{}var D=new WeakMap,B=new WeakMap,E=new WeakMap,ca=new WeakMap;class M{constructor(a){n(this,"version","0.3.0");l(this,D,0);l(this,B,void 0);l(this,E,void 0);l(this,ca,"normal gaussian boxMuller irwinHall bates batesgaussian bernoulli exponential pareto poisson hypergeometric rademacher binomial betaBinomial beta gamma studentsT wignerSemicircle kumaraswamy hermite chiSquared rayleigh logNormal cauchy laplace logistic".split(" "));this.setSeed(a)}getSeed(){return h(D,
this)}sameAs(a){return a instanceof M?this.getSeed()===a.getSeed()&&this.getRandomSource()===a.getRandomSource():!1}randomSource(a){m(B,this,a);return this}getRandomSource(){return h(B,this)}setSeed(a){if("undefined"!==typeof a&&null!==a)"string"===typeof a&&(a=this.convertStringToNumber(a)),m(D,this,a);else{a=this.setSeed;const b=Date.now();L=T===b?L+297357:0;T=b;return a.call(this,1E6*b+L)}return this}seed(a){this.setSeed(a);return this}serialize(){return{seed:h(D,this),version:"0.3.0"}}static unserialize(a){var b=
1<arguments.length&&void 0!==arguments[1]?arguments[1]:!1;let c;if((new x(null!=(c=a.version)?c:"0.1.0")).lt("0.2.0")&&!b)throw Error(`Trying to unserialize old RNG (v${a.version}) can lead to unexpected behaviour - minimum supported version for this iteration is ${"0.2.0"}.
  If you want to unserialize anyway, use the 'force' argument:

  GameRng.unserialize(serialized, true);`);b=new this(a.seed);b.seed(a.seed);return b}predictable(a){const {constructor:b}=Object.getPrototypeOf(this);return new b(null!=a?a:5789938451)}static predictable(a){return new this(null!=a?a:5789938451)}hashStr(a){let b=0,c,d;if(0===a.length)return b;for(c=0;c<a.length;c++)d=a.charCodeAt(c),b=(b<<5)-b+d,b|=0;return b}convertStringToNumber(a){if(K[a])return K[a];const b=this.hashStr(a);return K[a]=b}_random(){return"function"===typeof h(B,this)?h(B,this).call(this):
this._next()}percentage(){return this.randBetween(0,100)}probability(){return this.randBetween(0,1)}random(){return this.randBetween(0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,2<arguments.length&&void 0!==arguments[2]?arguments[2]:0)}chance(a){var b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;g({chanceIn:b}).positive();g({n:a}).positive();b=a/b;return this._random()<=b}chanceTo(a,b){return this.chance(a,a+b)}randInt(){let a=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;"object"===typeof a&&({from:a=0,to:b=1,skew:c=0}=a);g({from:a}).int();g({to:b}).int();if(a===b)return a;[a,b]=[Math.min(a,b),Math.max(a,b)];let d=this._random();d=0>c?1-Math.pow(d,Math.pow(2,c)):Math.pow(d,Math.pow(2,-c));return Math.floor(d*(b+1-a))+a}uniqid(){return P(0<arguments.length&&void 0!==arguments[0]?arguments[0]:
"")}static uniqid(){return P(0<arguments.length&&void 0!==arguments[0]?arguments[0]:"")}randomString(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:6;g({len:a}).gt(0);const b=[];for(let c=0;c<a;c++)b.push("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[this.randInt(0,61)]);return b.join("")}randBetween(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,b=1<arguments.length?arguments[1]:void 0,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;
"object"===typeof a&&({from:a=0,to:b,skew:c=0}=a);"undefined"===typeof b&&(b=a+1);[a,b]=[Math.min(a,b),Math.max(a,b)];let d=this._random();0>c?d=1-Math.pow(d,Math.pow(2,c)):0<c&&(d=Math.pow(d,Math.pow(2,-c)));return this.scaleNorm(d,a,b)}scale(a,b,c){let d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:0,e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:1;g({number:a}).lteq(e);g({number:a}).gteq(d);a=(a-d)/(e-d);return this.scaleNorm(a,b,c)}scaleNorm(a,b,c){g({number:a}).betweenEq(0,
1);return a*(c-b)+b}shouldThrowOnMaxRecursionsReached(a){return"boolean"===typeof a?(m(E,this,a),this):"undefined"!==typeof h(E,this)?h(E,this):!0}normal(){let {mean:a,stddev:b,max:c,min:d,skew:e=0}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},k=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;if("undefined"===typeof d&&"undefined"===typeof c)return this.gaussian({mean:a,stddev:b,skew:e});if(500<k&&this.shouldThrowOnMaxRecursionsReached())throw new U(`Max recursive calls to rng normal function. This might be as a result of using predictable random numbers, or inappropriate arguments? Args: ${JSON.stringify({mean:a,
stddev:b,max:c,min:d,skew:e})}`);let p=this.bates(7);p=0>e?1-Math.pow(p,Math.pow(2,e)):Math.pow(p,Math.pow(2,-e));if("undefined"===typeof a&&"undefined"===typeof b&&"undefined"!==typeof c&&"undefined"!==typeof d)return this.scaleNorm(p,d,c);"undefined"===typeof a?(a=0,"undefined"!==typeof c&&"undefined"!==typeof d&&(a=(c+d)/2,"undefined"===typeof b&&(b=Math.abs(c-d)/10)),"undefined"===typeof b&&(b=.1)):"undefined"===typeof b&&(b="undefined"!==typeof c&&"undefined"!==typeof d?Math.abs(c-d)/10:.1);
p=(10*p-5)*b+a;if(500>=k&&("undefined"!==typeof c&&p>c||"undefined"!==typeof d&&p<d))return this.normal({mean:a,stddev:b,max:c,min:d,skew:e},k+1);"undefined"!==typeof c&&(p=Math.min(p,c));"undefined"!==typeof d&&(p=Math.max(p,d));return p}gaussian(){let {mean:a=0,stddev:b=1,skew:c=0}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({stddev:b}).positive();if(0===c)return this.boxMuller({mean:a,stddev:b});let d=this.boxMuller({mean:0,stddev:1});d=d/10+.5;d=0>c?1-Math.pow(d,Math.pow(2,c)):
Math.pow(d,Math.pow(2,-c));return(10*d-5)*b+a}boxMuller(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;"object"===typeof a&&({mean:a=0,stddev:b=1}=a);g({stddev:b}).gteq(0);const c=1-this._random(),d=this._random();return Math.sqrt(-2*Math.log(c))*Math.cos(2*Math.PI*d)*b+a}irwinHall(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:6;"object"===typeof a&&({n:a=6}=a);g({n:a}).int().positive();let b=0;for(let c=
0;c<a;c++)b+=this._random();return b}bates(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:6;"object"===typeof a&&({n:a=6}=a);g({n:a}).int().positive();return this.irwinHall({n:a})/a}batesgaussian(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:6;"object"===typeof a&&({n:a=6}=a);g({n:a}).int().gt(1);return this.irwinHall({n:a})/Math.sqrt(a)-1/Math.sqrt(1/a)/2}bernoulli(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:.5;"object"===typeof a&&({p:a=.5}=a);
g({p:a}).lteq(1).gteq(0);return this._random()<a?1:0}exponential(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;"object"===typeof a&&({rate:a=1}=a);g({rate:a}).gt(0);return-Math.log(1-this._random())/a}pareto(){let {shape:a=.5,scale:b=1,location:c=0}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({shape:a}).gteq(0);g({scale:b}).positive();const d=this._random();return 0!==a?c+b/a*(Math.pow(d,-a)-1):c-b*Math.log(d)}poisson(){var a=0<arguments.length&&void 0!==arguments[0]?
arguments[0]:1;"object"===typeof a&&({lambda:a=1}=a);g({lambda:a}).positive();a=Math.exp(-a);let b=0,c=1,d=0;const e=new J(10,2);do{b++;const k=this._random();e.push(k);c*=k;e.detectLoop(`Loop detected in randomly generated numbers over the last ${10} generations. This is incompatible with the poisson distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul of the looped way of generating. Last random number was ${k}`)}while(c>a&&1E7>d++);if(1E7<=d+1)throw Error("LOOP_MAX reached in poisson - bailing out - possible parameter error, or using non-random source?");
return b-1}hypergeometric(){function a(q){let u=0;for(let r=2;r<=q;r++)u+=Math.log(r);return u}function b(q,u){return a(q)-a(u)-a(q-u)}let {N:c=50,K:d=10,n:e=5,k}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({N:c}).int().positive();g({K:d}).int().positive().lteq(c);g({n:e}).int().positive().lteq(c);"undefined"===typeof k&&(k=this.randInt(0,Math.min(d,e)));g({k}).int().betweenEq(0,Math.min(d,e));const p=b(d,k)+b(c-d,e-k)-b(c,e);return Math.exp(p)}rademacher(){return.5>this._random()?
-1:1}binomial(){let {n:a=1,p:b=.5}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({n:a}).int().positive();g({p:b}).betweenEq(0,1);let c=0;for(let d=0;d<a;d++)this._random()<b&&c++;return c}betaBinomial(){let {alpha:a=1,beta:b=1,n:c=1}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({alpha:a}).positive();g({beta:b}).positive();g({n:c}).int().positive();const d=((k,p)=>{let q=this._random(),u=this._random();q=Math.pow(q,1/k);u=Math.pow(u,1/p);return q/(q+u)})(a,b);let e=0;for(let k=
0;k<c;k++)this._random()<d&&e++;return e}beta(){let {alpha:a=.5,beta:b=.5}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({alpha:a}).positive();g({beta:b}).positive();var c=e=>{let k=0;for(let p=0;p<e;p++){const q=this._random();k+=-Math.log(q);if(1E7<=p+1)throw Error("LOOP_MAX reached in beta - bailing out - possible parameter error, or using non-random source?");}return k};const d=c(a);c=c(b);return d/(d+c)}gamma(){let {shape:a=1,rate:b,scale:c}=0<arguments.length&&void 0!==arguments[0]?
arguments[0]:{};g({shape:a}).positive();if("undefined"!==typeof c&&"undefined"!==typeof b&&b!==1/c)throw Error("Cannot supply rate and scale");"undefined"!==typeof c&&(g({scale:c}).positive(),b=1/c);"undefined"===typeof b&&(b=1);b&&g({rate:b}).positive();let d;let e=1;const k=a-1/3,p=1/Math.sqrt(9*k);let q=0;d=!0;const u=new J(10);for(;d&&1E7>q++;){var r=0;var v=new J(10);do{var A=this.normal();v.push(A);v.detectLoop("Loop detected in randomly generated numbers over the last 10 generations. This is incompatible with the gamma distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul ofthe looped way of generating.");
e=1+p*A}while(0>=e&&1E7>r++);if(1E7<=r+1)throw Error(`LOOP_MAX reached inside gamma inner loop - bailing out - possible parameter error, or using non-random source? had shape = ${a}, rate = ${b}, scale = ${c}`);e*=Math.pow(e,2);r=Math.pow(A,2);A=1-.331*r*r;r=.5*r+k*(1-e+Math.log(e));v=this._random();u.push(v);u.detectLoop(`Loop detected in randomly generated numbers over the last ${10} generations. This is incompatible with the gamma distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul of the looped way of generating. Last random number was ${v}`);
if(v<A||Math.log(v)<r)d=!1}if(1E7<=q+1)throw Error(`LOOP_MAX reached inside gamma - bailing out - possible parameter error, or using non-random source? had shape = ${a}, rate = ${b}, scale = ${c}`);return b*k*e}studentsT(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;"object"===typeof a&&({nu:a=1}=a);g({nu:a}).positive();const b=Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random()),c=this.gamma({shape:a/2,rate:2});return b/Math.sqrt(c/a)}wignerSemicircle(){let a=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;"object"===typeof a&&({R:a=1}=a);g({R:a}).gt(0);const b=2*this._random()*Math.PI;return a*Math.cos(b)}kumaraswamy(){let {alpha:a=.5,beta:b=.5}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({alpha:a}).gt(0);g({beta:b}).gt(0);const c=this._random();return Math.pow(1-Math.pow(1-c,1/b),1/a)}hermite(){let {lambda1:a=1,lambda2:b=2}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({lambda1:a}).gt(0);g({lambda2:b}).gt(0);const c=
this.poisson({lambda:a}),d=this.poisson({lambda:b});return c+d}chiSquared(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;"object"===typeof a&&({k:a=1}=a);g({k:a}).positive().int();let b=0;for(let c=0;c<a;c++){const d=Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random());b+=d*d}return b}rayleigh(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;"object"===typeof a&&({scale:a=1}=a);g({scale:a}).gt(0);return a*Math.sqrt(-2*Math.log(this._random()))}logNormal(){let {mean:a=
0,stddev:b=1}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({stddev:b}).gt(0);const c=a+b*Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random());return Math.exp(c)}cauchy(){let {median:a=0,scale:b=1}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({scale:b}).gt(0);const c=this._random();return a+b*Math.tan(Math.PI*(c-.5))}laplace(){let {mean:a=0,scale:b=1}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({scale:b}).gt(0);const c=this._random()-
.5;return a-b*Math.sign(c)*Math.log(1-2*Math.abs(c))}logistic(){let {mean:a=0,scale:b=1}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};g({scale:b}).gt(0);const c=this._random();return a+b*Math.log(c/(1-c))}support(a){return{random:"[min, max)",integer:"[min, max]",normal:"(-INF, INF)",boxMuller:"(-INF, INF)",gaussian:"(-INF, INF)",irwinHall:"[0, n]",bates:"[0, 1]",batesgaussian:"(-INF, INF)",bernoulli:"{0, 1}",exponential:"[0, INF)",pareto:"[scale, INF)",poisson:"{1, 2, 3 ...}",hypergeometric:"{max(0, n+K-N), ..., min(n, K)}",
rademacher:"{-1, 1}",binomial:"{0, 1, 2, ..., n}",betaBinomial:"{0, 1, 2, ..., n}",beta:"(0, 1)",gamma:"(0, INF)",studentsT:"(-INF, INF)",wignerSemicircle:"[-R; +R]",kumaraswamy:"(0, 1)",hermite:"{0, 1, 2, 3, ...}",chiSquared:"[0, INF)",rayleigh:"[0, INF)",logNormal:"(0, INF)",cauchy:"(-INF, +INF)",laplace:"(-INF, +INF)",logistic:"(-INF, +INF)"}[a]}chancyInt(a){if("number"===typeof a)return Math.round(a);if(Array.isArray(a)){for(var b of a)if(!G(b))throw Error("Cannot pass non-numbers to chancyInt");
a=this.choice(a);"number"!==typeof a&&(a=parseFloat(a));return Math.round(a)}if("object"===typeof a){a=Object.assign({},a);let c;b=null!=(c=a.type)?c:"random";"random"===b?a.type="integer":"normal"===b&&(a.type="normal_integer")}return Math.round(this.chancy(a))}chancy(a){let b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;if(500<=b){if(this.shouldThrowOnMaxRecursionsReached())throw new U("Max recursions reached in chancy. Usually a case of badly chosen min/max values.");return 0}if(Array.isArray(a))return this.choice(a);
if("string"===typeof a)return this.dice(a);if("object"===typeof a){a=Object.assign({},a);let c;a.type=null!=(c=a.type)?c:"random";"random"!==a.type&&"int"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==typeof a.max||(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "random":return this.random(a.min,a.max,a.skew);case "int":case "integer":return this.randInt(a.min,a.max,a.skew);case "normal_integer":case "normal_int":return Math.round(this.normal(a));case "dice":let d;return this.chancyMinMax(this.dice(null!=
(d=a.dice)?d:a),a,b);case "rademacher":return this.chancyMinMax(this.rademacher(),a,b);case "normal":case "gaussian":case "boxMuller":case "irwinHall":case "bates":case "batesgaussian":case "bernoulli":case "exponential":case "pareto":case "poisson":case "hypergeometric":case "binomial":case "betaBinomial":case "beta":case "gamma":case "studentsT":case "wignerSemicircle":case "kumaraswamy":case "hermite":case "chiSquared":case "rayleigh":case "logNormal":case "cauchy":case "laplace":case "logistic":return this.chancyMinMax(this[a.type](a),
a,b)}throw Error(`Invalid input type given to chancy: "${a.type}".`);}if("number"===typeof a)return a;throw Error("Invalid input given to chancy");}chancyMinMax(a,b){let c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;const {min:d,max:e}=b;return 500<=c+1&&!this.shouldThrowOnMaxRecursionsReached()?("undefined"!==typeof d&&(a=Math.max(d,a)),"undefined"!==typeof e&&(a=Math.min(e,a)),a):"undefined"!==typeof d&&a<d||"undefined"!==typeof e&&a>e?this.chancy(b,c+1):a}chancyMin(a){const {constructor:b}=
Object.getPrototypeOf(this);return b.chancyMin(a)}chancyMax(a){const {constructor:b}=Object.getPrototypeOf(this);return b.chancyMax(a)}static chancyMin(a){if(Array.isArray(a)){for(const b of a)if(!G(b))throw Error("Cannot pass non-numbers to chancyMin array input");return Math.min(...a)}if("string"===typeof a)return this.diceMin(a);if("number"===typeof a)return a;if("object"===typeof a){let b;a.type=null!=(b=a.type)?b:"random";"random"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==
typeof a.max||(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "dice":return this.diceMin(a.dice);case "normal":let c;return null!=(c=a.min)?c:Number.NEGATIVE_INFINITY;case "normal_integer":let d;return null!=(d=a.min)?d:Number.NEGATIVE_INFINITY;case "integer":let e;return null!=(e=a.min)?e:0;case "random":let k;return null!=(k=a.min)?k:0;case "boxMuller":return Number.NEGATIVE_INFINITY;case "gaussian":return Number.NEGATIVE_INFINITY;case "irwinHall":return 0;case "bates":return 0;case "batesgaussian":return Number.NEGATIVE_INFINITY;
case "bernoulli":return 0;case "exponential":return 0;case "pareto":let p;return null!=(p=a.scale)?p:1;case "poisson":return 1;case "hypergeometric":const {N:q=50,K:u=10,n:r=5}=a;return Math.max(0,r+u-q);case "rademacher":return-1;case "binomial":return 0;case "betaBinomial":return 0;case "beta":return Number.EPSILON;case "gamma":return Number.EPSILON;case "studentsT":return Number.NEGATIVE_INFINITY;case "wignerSemicircle":let v;return-1*(null!=(v=a.R)?v:10);case "kumaraswamy":return Number.EPSILON;
case "hermite":return 0;case "chiSquared":return 0;case "rayleigh":return 0;case "logNormal":return Number.EPSILON;case "cauchy":return Number.NEGATIVE_INFINITY;case "laplace":return Number.NEGATIVE_INFINITY;case "logistic":return Number.NEGATIVE_INFINITY}throw Error(`Invalid input type ${a.type}.`);}throw Error("Invalid input supplied to chancyMin");}static chancyMax(a){if(Array.isArray(a)){for(const b of a)if(!G(b))throw Error("Cannot pass non-numbers to chancyMax array input");return Math.max(...a)}if("string"===
typeof a)return this.diceMax(a);if("number"===typeof a)return a;if("object"===typeof a){let b;a.type=null!=(b=a.type)?b:"random";"random"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==typeof a.max||(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "dice":return this.diceMax(a.dice);case "normal":let c;return null!=(c=a.max)?c:Number.POSITIVE_INFINITY;case "normal_integer":let d;return null!=(d=a.max)?d:Number.POSITIVE_INFINITY;case "integer":let e;return null!=(e=a.max)?
e:1;case "random":let k;return null!=(k=a.max)?k:1;case "boxMuller":return Number.POSITIVE_INFINITY;case "gaussian":return Number.POSITIVE_INFINITY;case "irwinHall":let p;return null!=(p=a.n)?p:6;case "bates":return 1;case "batesgaussian":return Number.POSITIVE_INFINITY;case "bernoulli":return 1;case "exponential":return Number.POSITIVE_INFINITY;case "pareto":return Number.POSITIVE_INFINITY;case "poisson":return Number.MAX_SAFE_INTEGER;case "hypergeometric":const {K:q=10,n:u=5}=a;return Math.min(u,
q);case "rademacher":return 1;case "binomial":let r;return null!=(r=a.n)?r:1;case "betaBinomial":let v;return null!=(v=a.n)?v:1;case "beta":return 1;case "gamma":return Number.POSITIVE_INFINITY;case "studentsT":return Number.POSITIVE_INFINITY;case "wignerSemicircle":let A;return null!=(A=a.R)?A:10;case "kumaraswamy":return 1;case "hermite":return Number.MAX_SAFE_INTEGER;case "chiSquared":return Number.POSITIVE_INFINITY;case "rayleigh":return Number.POSITIVE_INFINITY;case "logNormal":return Number.POSITIVE_INFINITY;
case "cauchy":return Number.POSITIVE_INFINITY;case "laplace":return Number.POSITIVE_INFINITY;case "logistic":return Number.POSITIVE_INFINITY}throw Error(`Invalid input type ${a.type}.`);}throw Error("Invalid input supplied to chancyMax");}choice(a){return 0>=a.length?null:a[this.randInt(0,a.length-1)]}weights(a){const b=new Map;a.forEach(function(c){let d=0;b.has(c)&&(d=b.get(c));b.set(c,d+1)});return b}weightedChoice(a){let b=0;if(Array.isArray(a)){if(0===a.length)return null;if(1===a.length)return a[0];
a=this.weights(a);var c=this.weightedChoice(a);a.clear();return c}if(a instanceof Map){if(0===a.size)return null;if(1===a.size)return a.keys().next().value;a.forEach(k=>{b+=k})}else{var d=Object.keys(a);if(0===d.length)return null;if(1===d.length)return d[0];for(c in a){if(0>a[c])throw Error("Probability cannot be negative");b+=a[c]}}d=this._random()*b;let e=0;if(a instanceof Map)for(const [k,p]of a){if(e+=p,d<e)return k}else for(c in a)if(e+=a[c],d<e)break;return c}pool(a){return new Y(a,this)}static parseDiceArgs(){let a=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:6,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;if(null===a||"undefined"===typeof a||0>=arguments.length)throw Error("Dice expects at least one argument");if("string"===typeof a)return this.parseDiceString(a);if("object"===typeof a)if(Array.isArray(a))[a,b,c]=a;else{if("undefined"===typeof a.n&&"undefined"===typeof a.d&&"undefined"===typeof a.plus)throw Error("Invalid input given to dice related function - dice object must have at least one of n, d or plus properties.");
({n:a=1,d:b=6,plus:c=0}=a)}g({n:a}).int(`Expected n to be an integer, got ${a}`);g({d:b}).int(`Expected d to be an integer, got ${b}`);return{n:a,d:b,plus:c}}parseDiceArgs(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:6,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;const {constructor:d}=Object.getPrototypeOf(this);return d.parseDiceArgs(a,b,c)}static parseDiceString(a){if(!y[a]){var b=a.replace(/ +/g,"");if(/^[+-]*[\d.]+$/.test(b))return{n:0,
d:0,plus:parseFloat(b)};S.test(a)&&(b=S.exec(b),null!==b&&(y[a]={n:parseInt(b[1]),d:parseInt(b[2]),plus:parseFloat(b[3])},Number.isNaN(y[a].n)&&(y[a].n=1),Number.isNaN(y[a].d)&&(y[a].d=6),Number.isNaN(y[a].plus)&&(y[a].plus=0)));if("undefined"===typeof y[a])throw Error(`Could not parse dice string ${a}`);}return y[a]}diceMax(a,b,c){const {constructor:d}=Object.getPrototypeOf(this);return d.diceMax(a,b,c)}diceMin(a,b,c){const {constructor:d}=Object.getPrototypeOf(this);return d.diceMin(a,b,c)}static diceMax(){let a=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:6,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;({n:a,d:b,plus:c}=this.parseDiceArgs(a,b,c));return a*b+c}static diceMin(){let a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:6,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;({n:a,d:b,plus:c}=this.parseDiceArgs(a,b,c));return a+c}diceExpanded(){var a=
0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:6;let c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;({n:a,d:b,plus:c}=this.parseDiceArgs(a,b,c));if("number"===typeof a){let d=a;const e=Math.max(b,0);if(1===b)return{dice:Array(a).fill(b),plus:c,total:a*b+c};if(0===a||0===b)return{dice:[],plus:c,total:c};a=0>d?-1:1;d*=a;for(b={dice:[],plus:c,total:c};0<d;)b.dice.push(a*this.randInt(1,e)),d--;b.total=V(b.dice)+c;return b}throw Error("Invalid arguments given to dice");
}dice(a,b,c){return this.diceExpanded(a,b,c).total}parseDiceString(a){const {constructor:b}=Object.getPrototypeOf(this);return b.parseDiceString(a)}clamp(a,b,c){"undefined"!==typeof c&&(a=a<=c?a:c);"undefined"!==typeof b&&(a=a>=b?a:b);return a}bin(a,b,c,d){g({val:a}).gt(c).lt(d);d-=c;return Math.round((a-c)/d*(b-1))/(b-1)*d+c}shuffle(a){a=[...a];for(let b=a.length-1;0<b;b--){const c=Math.floor(this.random()*(b+1));[a[b],a[c]]=[a[c],a[b]]}return a}}n(M,"version","0.3.0");class C extends M{static predictable(a){return new this(null!=
a?a:5789938451)}serialize(){return{seed:this.getSeed(),version:"0.3.0"}}sameAs(a){return a instanceof C?this.getRandomSource()===a.getRandomSource()&&this.getSeed()===a.getSeed():!1}from(a){this.setSeed(a.getSeed());return this}_next(){this.setSeed(this.getSeed()+2654435769|0);let a=this.getSeed();a=Math.imul(a^a>>>16,569420461);a=Math.imul(a^a>>>15,1935289751);return((a^a>>>15)>>>0)/4294967296}rotCompatible(){const a=this;return{getUniform(){return a.random()},getUniformInt(b,c){return a.randInt(b,
c)},getNormal(){return a.boxMuller({mean:0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,stddev:1<arguments.length&&void 0!==arguments[1]?arguments[1]:1})},getPercentage(){return 1+Math.floor(100*this.getUniform())},getItem(b){return a.choice(b)},shuffle(b){return a.shuffle(b)},getWeightedValue(b){return a.weightedChoice(b)},getSeed(){return a.getSeed()},setSeed(b){a.setSeed(b);return this},getState(){return a.serialize()},setState(b){a.setSeed(b.seed);return this},clone(){return(new C).rotCompatible().setState(this.getState())}}}}
return C}();
