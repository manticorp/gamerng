var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.owns=function(g,e){return Object.prototype.hasOwnProperty.call(g,e)};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(g,e,k){if(g==Array.prototype||g==Object.prototype)return g;g[e]=k.value;return g};$jscomp.getGlobal=function(g){g=["object"==typeof globalThis&&globalThis,g,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var e=0;e<g.length;++e){var k=g[e];if(k&&k.Math==Math)return k}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(g,e,k){if(!k||null!=g){k=$jscomp.propertyToPolyfillSymbol[e];if(null==k)return g[e];k=g[k];return void 0!==k?k:g[e]}};
$jscomp.polyfill=function(g,e,k,m){e&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(g,e,k,m):$jscomp.polyfillUnisolated(g,e,k,m))};$jscomp.polyfillUnisolated=function(g,e,k,m){k=$jscomp.global;g=g.split(".");for(m=0;m<g.length-1;m++){var n=g[m];if(!(n in k))return;k=k[n]}g=g[g.length-1];m=k[g];e=e(m);e!=m&&null!=e&&$jscomp.defineProperty(k,g,{configurable:!0,writable:!0,value:e})};
$jscomp.polyfillIsolated=function(g,e,k,m){var n=g.split(".");g=1===n.length;m=n[0];m=!g&&m in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var B=0;B<n.length-1;B++){var C=n[B];if(!(C in m))return;m=m[C]}n=n[n.length-1];k=$jscomp.IS_SYMBOL_NATIVE&&"es6"===k?m[n]:null;e=e(k);null!=e&&(g?$jscomp.defineProperty($jscomp.polyfills,n,{configurable:!0,writable:!0,value:e}):e!==k&&(void 0===$jscomp.propertyToPolyfillSymbol[n]&&(k=1E9*Math.random()>>>0,$jscomp.propertyToPolyfillSymbol[n]=$jscomp.IS_SYMBOL_NATIVE?
$jscomp.global.Symbol(n):$jscomp.POLYFILL_PREFIX+k+"$"+n),$jscomp.defineProperty(m,$jscomp.propertyToPolyfillSymbol[n],{configurable:!0,writable:!0,value:e})))};$jscomp.polyfill("Object.entries",function(g){return g?g:function(e){var k=[],m;for(m in e)$jscomp.owns(e,m)&&k.push([m,e[m]]);return k}},"es8","es3");
$jscomp.checkStringArgs=function(g,e,k){if(null==g)throw new TypeError("The 'this' value for String.prototype."+k+" must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype."+k+" must not be a regular expression");return g+""};$jscomp.stringPadding=function(g,e){g=void 0!==g?String(g):" ";return 0<e&&g?g.repeat(Math.ceil(e/g.length)).substring(0,e):""};
$jscomp.polyfill("String.prototype.padEnd",function(g){return g?g:function(e,k){var m=$jscomp.checkStringArgs(this,null,"padStart");return m+$jscomp.stringPadding(k,e-m.length)}},"es8","es3");
var GameRng=function(){function g(a){return"number"===typeof a||!isNaN(parseFloat(a))&&isFinite(a)}function e(a){if(Array.isArray(a))return new P(a);if("object"===typeof a){a=Object.entries(a);if(0===a.length)throw Error("Empty object provided");const [b,c]=a[0];return e(c).varname(b)}return new Q(a)}function k(a=""){const b=1E3*Date.now();R===b?H++:H=0;const c=(b+H).toString(16).replace(/\./g,"").padEnd(14,"0");R=b;return`${a}${c}`}function m(a,...b){return Array.isArray(a)?a.reduce((c,d)=>c+d,0):
b.reduce((c,d)=>c+d,0)}function n(a){return"number"===typeof a||!isNaN(parseFloat(a))&&isFinite(a)}var B=function(a,b,c,d){if("a"===c&&!d)throw new TypeError("Private accessor was defined without a getter");if("function"===typeof b?a!==b||!d:!b.has(a))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===c?d:"a"===c?d.call(a):d?d.value:b.get(a)},C=function(a,b,c,d,f){if("m"===d)throw new TypeError("Private method is not writable");if("a"===d&&
!f)throw new TypeError("Private accessor was defined without a setter");if("function"===typeof b?a!==b||!f:!b.has(a))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===d?f.call(a,c):f?f.value=c:b.set(a,c),c};const p=(a,b="Assertion failed")=>{if(!a)throw new X(b);};class X extends Error{}class P{constructor(a,b="numbers"){I.set(this,[]);this.name="numbers";this.numbers=a;this.name=b}get numbers(){return B(this,I,"f")}set numbers(a){for(const b of a)p("number"===
typeof b,`Non-number passed to validator ${b}`);C(this,I,a,"f")}all(a){this.numbers=a;return this}validate(a){return Array.isArray(a)?this.all(a):new Q(a)}varname(a){this.name=a;return this}sum(){return this.numbers.reduce((a,b)=>a+b,0)}sumcloseto(a,b=1E-4,c){p(Math.abs(this.sum()-a)<b,null!==c&&void 0!==c?c:`Expected sum of ${this.name} to be within ${b} of ${a}, got ${this.sum()}`);return this}sumto(a,b){p(this.sum()===a,null!==b&&void 0!==b?b:`Expected sum of ${this.name} to be equal to ${a}, got ${this.sum()}`);
return this}sumtolt(a,b){p(this.sum()<a,null!==b&&void 0!==b?b:`Expected sum of ${this.name} to be less than ${a}, got ${this.sum()}`);return this}sumtogt(a,b){p(this.sum()>a,null!==b&&void 0!==b?b:`Expected sum of ${this.name} to be greater than ${a}, got ${this.sum()}`);return this}sumtolteq(a,b){p(this.sum()<=a,null!==b&&void 0!==b?b:`Expected sum of ${this.name} to be less than or equal to ${a}, got ${this.sum()}`);return this}sumtogteq(a,b){p(this.sum()>=a,null!==b&&void 0!==b?b:`Expected sum of ${this.name} to be greater than or equal to ${a}, got ${this.sum()}`);
return this}int(a){this.numbers.forEach(b=>e(b).int(null!==a&&void 0!==a?a:`Expected every component of ${this.name} to be an integer, got ${b}`));return this}positive(a){this.numbers.forEach(b=>e(b).positive(null!==a&&void 0!==a?a:`Expected every component of ${this.name} to be postiive, got ${b}`));return this}negative(a){this.numbers.forEach(b=>e(b).negative(null!==a&&void 0!==a?a:`Expected every component of ${this.name} to be negative, got ${b}`));return this}between(a,b,c){this.numbers.forEach(d=>
e(d).between(a,b,null!==c&&void 0!==c?c:`Expected every component of ${this.name} to be between ${a} and ${b}, got ${d}`));return this}betweenEq(a,b,c){this.numbers.forEach(d=>e(d).betweenEq(a,b,null!==c&&void 0!==c?c:`Expected every component of ${this.name} to be between or equal to ${a} and ${b}, got ${d}`));return this}gt(a,b){this.numbers.forEach(c=>e(c).gt(a,null!==b&&void 0!==b?b:`Expected every component of ${this.name} to be > ${a}, got ${c}`));return this}gteq(a,b){this.numbers.forEach(c=>
e(c).gteq(a,null!==b&&void 0!==b?b:`Expected every component of ${this.name} to be >= ${a}, got ${c}`));return this}lt(a,b){this.numbers.forEach(c=>e(c).lt(a,null!==b&&void 0!==b?b:`Expected every component of ${this.name} to be < ${a}, got ${c}`));return this}lteq(a,b){this.numbers.forEach(c=>e(c).lteq(a,null!==b&&void 0!==b?b:`Expected every component of ${this.name} to be <= ${a}, got ${c}`));return this}}var I=new WeakMap;class Q{constructor(a=0,b="number"){J.set(this,void 0);this.name="number";
"string"===typeof a&&(a=parseFloat(a));this.number=a;this.name=b}get number(){return B(this,J,"f")}set number(a){p(g(a),`Non-number passed to validator ${a}`);"string"===typeof a&&(a=parseFloat("number"));C(this,J,a,"f")}all(a,b){return new P(a,null!==b&&void 0!==b?b:this.name)}assertNumber(a){p("undefined"!==typeof a,"No number passed to validator.");return!0}varname(a){this.name=a;return this}validate(a){if(Array.isArray(a))return this.all(a);this.number=a;return this}integer(a){return this.int(a)}int(a){this.assertNumber(this.number)&&
p(Number.isInteger(this.number),null!==a&&void 0!==a?a:`Expected ${this.name} to be an integer, got ${this.number}`);return this}positive(a){return this.gt(0,null!==a&&void 0!==a?a:`Expected ${this.name} to be positive, got ${this.number}`)}negative(a){return this.lt(0,null!==a&&void 0!==a?a:`Expected ${this.name} to be negative, got ${this.number}`)}between(a,b,c){this.assertNumber(this.number)&&p(this.number>a&&this.number<b,null!==c&&void 0!==c?c:`Expected ${this.name} to be between ${a} and ${b}, got ${this.number}`);
return this}betweenEq(a,b,c){this.assertNumber(this.number)&&p(this.number>=a&&this.number<=b,null!==c&&void 0!==c?c:`Expected ${this.name} to be between or equal to ${a} and ${b}, got ${this.number}`);return this}gt(a,b){this.assertNumber(this.number)&&p(this.number>a,null!==b&&void 0!==b?b:`Expected ${this.name} to be greater than ${a}, got ${this.number}`);return this}gteq(a,b){this.assertNumber(this.number)&&p(this.number>=a,null!==b&&void 0!==b?b:`Expected ${this.name} to be greater than or equal to ${a}, got ${this.number}`);
return this}lt(a,b){this.assertNumber(this.number)&&p(this.number<a,null!==b&&void 0!==b?b:`Expected ${this.name} to be less than ${a}, got ${this.number}`);return this}lteq(a,b){this.assertNumber(this.number)&&p(this.number<=a,null!==b&&void 0!==b?b:`Expected ${this.name} to be less than or equal to ${a}, got ${this.number}`);return this}}var J=new WeakMap;var y=function(a,b,c,d){if("a"===c&&!d)throw new TypeError("Private accessor was defined without a getter");if("function"===typeof b?a!==b||!d:
!b.has(a))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===c?d:"a"===c?d.call(a):d?d.value:b.get(a)},S=function(a,b,c,d,f){if("m"===d)throw new TypeError("Private method is not writable");if("a"===d&&!f)throw new TypeError("Private accessor was defined without a setter");if("function"===typeof b?a!==b||!f:!b.has(a))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===d?f.call(a,c):f?f.value=
c:b.set(a,c),c};class T extends Error{}class Y extends Error{}class Z{constructor(a=[],b){v.set(this,[]);this.entries=a;this.rng=b?b:new E}copyArray(a){return Array.from(a)}setEntries(a){this.entries=a;return this}getEntries(){return y(this,v,"f")}set entries(a){S(this,v,this.copyArray(a),"f")}get entries(){return y(this,v,"f")}get length(){return y(this,v,"f").length}setRng(a){this.rng=a;return this}getRng(){return this.rng}add(a){y(this,v,"f").push(a)}empty(){S(this,v,[],"f");return this}isEmpty(){return 0>=
this.length}draw(){if(0===this.length)throw new T("No more elements left to draw from in pool.");if(1===this.length)return y(this,v,"f").splice(0,1)[0];const a=this.rng.randInt(0,y(this,v,"f").length-1);return y(this,v,"f").splice(a,1)[0]}drawMany(a){if(0>a)throw Error("Cannot draw < 0 elements from pool");if(0===this.length&&0<a)throw new T("No more elements left to draw from in pool.");if(this.length<a)throw new Y(`Tried to draw ${a} elements from pool with only ${this.length} entries.`);const b=
[];for(let c=0;c<a;c++){const d=this.rng.randInt(0,y(this,v,"f").length-1);b.push(y(this,v,"f").splice(d,1)[0])}return b}}var v=new WeakMap;class aa{constructor(a=1){this.elements=[];Array.isArray(a)?(this.elements=a,this.size=this.elements.length):this.size=a}get length(){return this.elements.length}push(a){this.elements.push(a);if(this.elements.length>this.size)return this.pop()}pop(){return this.elements.pop()}full(){return this.length>=this.size}empty(){this.elements=[]}get(a){return this.elements[a]}allSame(){return 0<
this.length?this.elements.every(a=>a===this.elements[0]):!0}}class ba extends Error{}class K extends aa{constructor(a=1,b=2){super(a);this.minsequencelength=2;this.errormessage="Loop detected in input data. Randomness source not random?";if(1E4<this.size)throw Error("Cannot detect loops for more than 10000 elements");this.minsequencelength=b}push(a){this.detectLoop();this.elements.push(a);if(this.elements.length>this.size)return this.pop()}detectLoop(a){this.full()&&(this.allSame()&&this.loopDetected(a),
this.hasRepeatingSequence(this.elements,this.minsequencelength)&&this.loopDetected(a))}loopDetected(a){throw new ba(null!==a&&void 0!==a?a:this.errormessage);}hasRepeatingSequence(a,b){for(let c=0;c<a.length;c++)for(let d=c+1;d<a.length;d++){let f=0;for(;d+f<a.length&&a[c+f]===a[d+f];)if(f++,f>b)return!0}return!1}}const ca=/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
class w{constructor(a,b,c=0,d,f){var h;this.patch=this.minor=this.major=0;this.presplit=[];a instanceof w?(this.major=a.major,this.minor=a.minor,this.patch=a.patch,this.presplit=a.presplit,this.build=a.build):("object"===typeof a?({major:a=0,minor:b,patch:c=0,prerelease:d,build:f}=a,this.major="string"===typeof a?parseInt(a):a,this.minor=null!==(h="string"===typeof b?parseInt(b):b)&&void 0!==h?h:0===this.major?1:0,this.patch="string"===typeof c?parseInt(c):c):("string"===typeof a&&"undefined"===typeof b?
({major:a,minor:b,patch:c,prerelease:d,build:f}=w.parse(a),this.major=a,this.minor=b):(a="string"===typeof a?parseInt(a):a,b="string"===typeof b?parseInt(b):b,c="string"===typeof c?parseInt(c):c,this.major=a,this.minor=null!==b&&void 0!==b?b:0===a?1:0),this.patch=c),this.prerelease=d,this.build=f);e({major:this.major}).gteq(0).integer();e({minor:this.minor}).gteq(0).integer();e({patch:this.patch}).gteq(0).integer()}get prerelease(){if(0!==this.presplit.length)return this.presplit.join(".")}set prerelease(a){this.presplit=
this.splitPre(a)}splitPre(a){if("undefined"===typeof a||""===a)return[];a=`${a}`.trim();return a.split(".").map(b=>{if(g(b)){const c=+b;if(0<=c&&c<Number.MAX_SAFE_INTEGER)return c}return b})}static parse(a){a=ca.exec(a);if(null===a)throw Error("Invalid semver string.");let [b,c,d,f,h]=Array.from(a).slice(1);b=parseInt(b);c=parseInt(c);d=parseInt(d);return new w({major:b,minor:c,patch:d,prerelease:f,build:h})}plain(){return{major:this.major,minor:this.minor,patch:this.patch,prerelease:this.prerelease,
build:this.build}}toString(){let a=`${this.major}.${this.minor}.${this.patch}`;0<this.presplit.length&&(a=`${a}-${this.presplit.join(".")}`);"undefined"!==typeof this.build&&(a=`${a}+${this.build}`);return a}comparePrerelease(a){a=new w(a);if(this.presplit.length&&!a.presplit.length)return-1;if(!this.presplit.length&&a.presplit.length)return 1;if(!this.presplit.length&&!a.presplit.length)return 0;var b=0;do{var c=this.presplit[b],d=a.presplit[b];if(void 0===c&&void 0===d)break;else{if(void 0===d)return 1;
if(void 0===c)return-1;if(c!==d)return a=c,b=g(a),c=g(d),b&&c&&(a=+a,d=+d),a===d?0:b&&!c?-1:c&&!b?1:a<d?-1:1}}while(++b);return 0}gt(a){a=new w(a);return 0<this.presplit.length&&0<a.presplit.length?this.sameVer(a)?0>=this.comparePrerelease(a)?!1:!0:!1:this.major>a.major||this.minor>a.minor||this.patch>a.patch||0===this.presplit.length&&0<a.presplit.length?!0:!1}gteq(a){a=new w(a);return this.gt(a)||this.eq(a)}sameVer(a){a=new w(a);return this.major===a.major&&this.minor===a.minor&&this.patch===a.patch}eq(a){a=
new w(a);return this.sameVer(a)&&this.samePre(a)}samePre(a){a=new w(a);return this.prerelease===a.prerelease}same(a){const b=new w(a);return this.eq(a)&&this.build===b.build}lt(a){a=new w(a);return 0<this.presplit.length&&0<a.presplit.length?this.sameVer(a)?0<=this.comparePrerelease(a)?!1:!0:!1:this.major<a.major||this.minor<a.minor||this.patch<a.patch?!0:!1}lteq(a){return this.lt(a)||this.eq(a)}}var z=function(a,b,c,d){if("a"===c&&!d)throw new TypeError("Private accessor was defined without a getter");
if("function"===typeof b?a!==b||!d:!b.has(a))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===c?d:"a"===c?d.call(a):d?d.value:b.get(a)},L=function(a,b,c,d,f){if("m"===d)throw new TypeError("Private method is not writable");if("a"===d&&!f)throw new TypeError("Private accessor was defined without a setter");if("function"===typeof b?a!==b||!f:!b.has(a))throw new TypeError("Cannot write private member to an object whose class did not declare it");
return"a"===d?f.call(a,c):f?f.value=c:b.set(a,c),c};const U=/^ *([+-]? *[0-9_]*) *[dD] *([0-9_]+) *([+-]? *[0-9_.]*) *$/,M={},x={};let H=0,R=0,V=Date.now(),N=0;class W extends Error{}class O{constructor(a){this.version="0.2.1";F.set(this,0);D.set(this,void 0);G.set(this,void 0);da.set(this,"normal gaussian boxMuller irwinHall bates batesgaussian bernoulli exponential pareto poisson hypergeometric rademacher binomial betaBinomial beta gamma studentsT wignerSemicircle kumaraswamy hermite chiSquared rayleigh logNormal cauchy laplace logistic".split(" "));
this.setSeed(a)}getSeed(){return z(this,F,"f")}sameAs(a){return a instanceof O?this.getSeed()===a.getSeed()&&this.getRandomSource()===a.getRandomSource():!1}randomSource(a){L(this,D,a,"f");return this}getRandomSource(){return z(this,D,"f")}setSeed(a){if("undefined"!==typeof a&&null!==a)"string"===typeof a&&(a=this.convertStringToNumber(a)),L(this,F,a,"f");else{a=this.setSeed;const b=Date.now();N=V===b?N+297357:0;V=b;return a.call(this,1E6*b+N)}return this}seed(a){this.setSeed(a);return this}serialize(){return{seed:z(this,
F,"f"),version:"0.2.1"}}static unserialize(a,b=!1){var c;if((new w(null!==(c=a.version)&&void 0!==c?c:"0.1.0")).lt("0.2.0")&&!b)throw Error(`Trying to unserialize old RNG (v${a.version}) can lead to unexpected behaviour - minimum supported version for this iteration is ${"0.2.0"}.
  If you want to unserialize anyway, use the 'force' argument:

  GameRng.unserialize(serialized, true);`);b=new this(a.seed);b.seed(a.seed);return b}predictable(a){const {constructor:b}=Object.getPrototypeOf(this);return new b(null!==a&&void 0!==a?a:5789938451)}static predictable(a){return new this(null!==a&&void 0!==a?a:5789938451)}hashStr(a){let b=0,c,d;if(0===a.length)return b;for(c=0;c<a.length;c++)d=a.charCodeAt(c),b=(b<<5)-b+d,b|=0;return b}convertStringToNumber(a){if(M[a])return M[a];const b=this.hashStr(a);return M[a]=b}_random(){return"function"===typeof z(this,
D,"f")?z(this,D,"f").call(this):this._next()}percentage(){return this.randBetween(0,100)}probability(){return this.randBetween(0,1)}random(a=0,b=1,c=0){return this.randBetween(a,b,c)}chance(a,b=1){e({chanceIn:b}).positive();e({n:a}).positive();a/=b;return this._random()<=a}chanceTo(a,b){return this.chance(a,a+b)}randInt(a=0,b=1,c=0){e({from:a}).int();e({to:b}).int();if(a===b)return a;[a,b]=[Math.min(a,b),Math.max(a,b)];let d=this._random();d=0>c?1-Math.pow(d,Math.pow(2,c)):Math.pow(d,Math.pow(2,-c));
return Math.floor(d*(b+1-a))+a}uniqid(a=""){return k(a)}static uniqid(a=""){return k(a)}randomString(a=6){e({len:a}).gt(0);const b=[];for(let c=0;c<a;c++)b.push("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[this.randInt(0,61)]);return b.join("")}randBetween(a=0,b,c=0){"undefined"===typeof b&&(b=a+1);[a,b]=[Math.min(a,b),Math.max(a,b)];let d=this._random();0>c?d=1-Math.pow(d,Math.pow(2,c)):0<c&&(d=Math.pow(d,Math.pow(2,-c)));return this.scaleNorm(d,a,b)}scale(a,b,c,d=0,f=1){e({number:a}).lteq(f);
e({number:a}).gteq(d);return this.scaleNorm((a-d)/(f-d),b,c)}scaleNorm(a,b,c){e({number:a}).betweenEq(0,1);return a*(c-b)+b}shouldThrowOnMaxRecursionsReached(a){return"boolean"===typeof a?(L(this,G,a,"f"),this):"undefined"!==typeof z(this,G,"f")?z(this,G,"f"):!0}normal({mean:a,stddev:b,max:c,min:d,skew:f=0}={},h=0){if("undefined"===typeof d&&"undefined"===typeof c)return this.gaussian({mean:a,stddev:b,skew:f});if(500<h&&this.shouldThrowOnMaxRecursionsReached())throw new W(`Max recursive calls to rng normal function. This might be as a result of using predictable random numbers, or inappropriate arguments? Args: ${JSON.stringify({mean:a,
stddev:b,max:c,min:d,skew:f})}`);let l=this.bates(7);l=0>f?1-Math.pow(l,Math.pow(2,f)):Math.pow(l,Math.pow(2,-f));if("undefined"===typeof a&&"undefined"===typeof b&&"undefined"!==typeof c&&"undefined"!==typeof d)return this.scaleNorm(l,d,c);"undefined"===typeof a?(a=0,"undefined"!==typeof c&&"undefined"!==typeof d&&(a=(c+d)/2,"undefined"===typeof b&&(b=Math.abs(c-d)/10)),"undefined"===typeof b&&(b=.1)):"undefined"===typeof b&&(b="undefined"!==typeof c&&"undefined"!==typeof d?Math.abs(c-d)/10:.1);
l=(10*l-5)*b+a;if(500>=h&&("undefined"!==typeof c&&l>c||"undefined"!==typeof d&&l<d))return this.normal({mean:a,stddev:b,max:c,min:d,skew:f},h+1);"undefined"!==typeof c&&(l=Math.min(l,c));"undefined"!==typeof d&&(l=Math.max(l,d));return l}gaussian({mean:a=0,stddev:b=1,skew:c=0}={}){e({stddev:b}).positive();if(0===c)return this.boxMuller({mean:a,stddev:b});let d=this.boxMuller({mean:0,stddev:1});d=d/10+.5;d=0>c?1-Math.pow(d,Math.pow(2,c)):Math.pow(d,Math.pow(2,-c));return(10*d-5)*b+a}boxMuller(a=0,
b=1){"object"===typeof a&&({mean:a=0,stddev:b=1}=a);e({stddev:b}).gteq(0);const c=1-this._random(),d=this._random();return Math.sqrt(-2*Math.log(c))*Math.cos(2*Math.PI*d)*b+a}irwinHall(a=6){"object"===typeof a&&({n:a=6}=a);e({n:a}).int().positive();let b=0;for(let c=0;c<a;c++)b+=this._random();return b}bates(a=6){"object"===typeof a&&({n:a=6}=a);e({n:a}).int().positive();return this.irwinHall({n:a})/a}batesgaussian(a=6){"object"===typeof a&&({n:a=6}=a);e({n:a}).int().gt(1);return this.irwinHall({n:a})/
Math.sqrt(a)-1/Math.sqrt(1/a)/2}bernoulli(a=.5){"object"===typeof a&&({p:a=.5}=a);e({p:a}).lteq(1).gteq(0);return this._random()<a?1:0}exponential(a=1){"object"===typeof a&&({rate:a=1}=a);e({rate:a}).gt(0);return-Math.log(1-this._random())/a}pareto({shape:a=.5,scale:b=1,location:c=0}={}){e({shape:a}).gteq(0);e({scale:b}).positive();const d=this._random();return 0!==a?c+b/a*(Math.pow(d,-a)-1):c-b*Math.log(d)}poisson(a=1){"object"===typeof a&&({lambda:a=1}=a);e({lambda:a}).positive();a=Math.exp(-a);
let b=0,c=1,d=0;const f=new K(10,2);do{b++;const h=this._random();f.push(h);c*=h;f.detectLoop(`Loop detected in randomly generated numbers over the last ${10} generations. This is incompatible with the poisson distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul of the looped way of generating. Last random number was ${h}`)}while(c>a&&1E7>d++);if(1E7<=d+1)throw Error("LOOP_MAX reached in poisson - bailing out - possible parameter error, or using non-random source?");
return b-1}hypergeometric({N:a=50,K:b=10,n:c=5,k:d}={}){function f(l){let q=0;for(let r=2;r<=l;r++)q+=Math.log(r);return q}function h(l,q){return f(l)-f(q)-f(l-q)}e({N:a}).int().positive();e({K:b}).int().positive().lteq(a);e({n:c}).int().positive().lteq(a);"undefined"===typeof d&&(d=this.randInt(0,Math.min(b,c)));e({k:d}).int().betweenEq(0,Math.min(b,c));a=h(b,d)+h(a-b,c-d)-h(a,c);return Math.exp(a)}rademacher(){return.5>this._random()?-1:1}binomial({n:a=1,p:b=.5}={}){e({n:a}).int().positive();e({p:b}).betweenEq(0,
1);let c=0;for(let d=0;d<a;d++)this._random()<b&&c++;return c}betaBinomial({alpha:a=1,beta:b=1,n:c=1}={}){e({alpha:a}).positive();e({beta:b}).positive();e({n:c}).int().positive();a=((d,f)=>{let h=this._random(),l=this._random();h=Math.pow(h,1/d);l=Math.pow(l,1/f);return h/(h+l)})(a,b);b=0;for(let d=0;d<c;d++)this._random()<a&&b++;return b}beta({alpha:a=.5,beta:b=.5}={}){e({alpha:a}).positive();e({beta:b}).positive();const c=d=>{let f=0;for(let h=0;h<d;h++){const l=this._random();f+=-Math.log(l);if(1E7<=
h+1)throw Error("LOOP_MAX reached in beta - bailing out - possible parameter error, or using non-random source?");}return f};a=c(a);b=c(b);return a/(a+b)}gamma({shape:a=1,rate:b,scale:c}={}){e({shape:a}).positive();if("undefined"!==typeof c&&"undefined"!==typeof b&&b!==1/c)throw Error("Cannot supply rate and scale");"undefined"!==typeof c&&(e({scale:c}).positive(),b=1/c);"undefined"===typeof b&&(b=1);b&&e({rate:b}).positive();let d;let f=1;const h=a-1/3,l=1/Math.sqrt(9*h);let q=0;d=!0;const r=new K(10);
for(;d&&1E7>q++;){var t=0;var u=new K(10);do{var A=this.normal();u.push(A);u.detectLoop("Loop detected in randomly generated numbers over the last 10 generations. This is incompatible with the gamma distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul ofthe looped way of generating.");f=1+l*A}while(0>=f&&1E7>t++);if(1E7<=t+1)throw Error(`LOOP_MAX reached inside gamma inner loop - bailing out - possible parameter error, or using non-random source? had shape = ${a}, rate = ${b}, scale = ${c}`);
f*=Math.pow(f,2);t=Math.pow(A,2);A=1-.331*t*t;t=.5*t+h*(1-f+Math.log(f));u=this._random();r.push(u);r.detectLoop(`Loop detected in randomly generated numbers over the last ${10} generations. This is incompatible with the gamma distribution. Try either using a spread of non-random numbers or fine tune the number to not fall foul of the looped way of generating. Last random number was ${u}`);if(u<A||Math.log(u)<t)d=!1}if(1E7<=q+1)throw Error(`LOOP_MAX reached inside gamma - bailing out - possible parameter error, or using non-random source? had shape = ${a}, rate = ${b}, scale = ${c}`);
return b*h*f}studentsT(a=1){"object"===typeof a&&({nu:a=1}=a);e({nu:a}).positive();const b=Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random()),c=this.gamma({shape:a/2,rate:2});return b/Math.sqrt(c/a)}wignerSemicircle(a=1){"object"===typeof a&&({R:a=1}=a);e({R:a}).gt(0);const b=2*this._random()*Math.PI;return a*Math.cos(b)}kumaraswamy({alpha:a=.5,beta:b=.5}={}){e({alpha:a}).gt(0);e({beta:b}).gt(0);const c=this._random();return Math.pow(1-Math.pow(1-c,1/b),1/a)}hermite({lambda1:a=
1,lambda2:b=2}={}){e({lambda1:a}).gt(0);e({lambda2:b}).gt(0);a=this.poisson({lambda:a});b=this.poisson({lambda:b});return a+b}chiSquared(a=1){"object"===typeof a&&({k:a=1}=a);e({k:a}).positive().int();let b=0;for(let c=0;c<a;c++){const d=Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random());b+=d*d}return b}rayleigh(a=1){"object"===typeof a&&({scale:a=1}=a);e({scale:a}).gt(0);return a*Math.sqrt(-2*Math.log(this._random()))}logNormal({mean:a=0,stddev:b=1}={}){e({stddev:b}).gt(0);
a+=b*Math.sqrt(-2*Math.log(this._random()))*Math.cos(2*Math.PI*this._random());return Math.exp(a)}cauchy({median:a=0,scale:b=1}={}){e({scale:b}).gt(0);const c=this._random();return a+b*Math.tan(Math.PI*(c-.5))}laplace({mean:a=0,scale:b=1}={}){e({scale:b}).gt(0);const c=this._random()-.5;return a-b*Math.sign(c)*Math.log(1-2*Math.abs(c))}logistic({mean:a=0,scale:b=1}={}){e({scale:b}).gt(0);const c=this._random();return a+b*Math.log(c/(1-c))}support(a){return{random:"[min, max)",integer:"[min, max]",
normal:"(-INF, INF)",boxMuller:"(-INF, INF)",gaussian:"(-INF, INF)",irwinHall:"[0, n]",bates:"[0, 1]",batesgaussian:"(-INF, INF)",bernoulli:"{0, 1}",exponential:"[0, INF)",pareto:"[scale, INF)",poisson:"{1, 2, 3 ...}",hypergeometric:"{max(0, n+K-N), ..., min(n, K)}",rademacher:"{-1, 1}",binomial:"{0, 1, 2, ..., n}",betaBinomial:"{0, 1, 2, ..., n}",beta:"(0, 1)",gamma:"(0, INF)",studentsT:"(-INF, INF)",wignerSemicircle:"[-R; +R]",kumaraswamy:"(0, 1)",hermite:"{0, 1, 2, 3, ...}",chiSquared:"[0, INF)",
rayleigh:"[0, INF)",logNormal:"(0, INF)",cauchy:"(-INF, +INF)",laplace:"(-INF, +INF)",logistic:"(-INF, +INF)"}[a]}chancyInt(a){var b;if("number"===typeof a)return Math.round(a);if(Array.isArray(a)){for(var c of a)if(!n(c))throw Error("Cannot pass non-numbers to chancyInt");a=this.choice(a);"number"!==typeof a&&(a=parseFloat(a));return Math.round(a)}"object"===typeof a&&(a=Object.assign({},a),c=null!==(b=a.type)&&void 0!==b?b:"random","random"===c?a.type="integer":"normal"===c&&(a.type="normal_integer"));
return Math.round(this.chancy(a))}chancy(a,b=0){var c,d;if(500<=b){if(this.shouldThrowOnMaxRecursionsReached())throw new W("Max recursions reached in chancy. Usually a case of badly chosen min/max values.");return 0}if(Array.isArray(a))return this.choice(a);if("string"===typeof a)return this.dice(a);if("object"===typeof a){a=Object.assign({},a);a.type=null!==(c=a.type)&&void 0!==c?c:"random";"random"!==a.type&&"int"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==typeof a.max||
(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "random":return this.random(a.min,a.max,a.skew);case "int":case "integer":return this.randInt(a.min,a.max,a.skew);case "normal_integer":case "normal_int":return Math.round(this.normal(a));case "dice":return this.chancyMinMax(this.dice(null!==(d=a.dice)&&void 0!==d?d:a),a,b);case "rademacher":return this.chancyMinMax(this.rademacher(),a,b);case "normal":case "gaussian":case "boxMuller":case "irwinHall":case "bates":case "batesgaussian":case "bernoulli":case "exponential":case "pareto":case "poisson":case "hypergeometric":case "binomial":case "betaBinomial":case "beta":case "gamma":case "studentsT":case "wignerSemicircle":case "kumaraswamy":case "hermite":case "chiSquared":case "rayleigh":case "logNormal":case "cauchy":case "laplace":case "logistic":return this.chancyMinMax(this[a.type](a),
a,b)}throw Error(`Invalid input type given to chancy: "${a.type}".`);}if("number"===typeof a)return a;throw Error("Invalid input given to chancy");}chancyMinMax(a,b,c=0){const {min:d,max:f}=b;return 500<=c+1&&!this.shouldThrowOnMaxRecursionsReached()?("undefined"!==typeof d&&(a=Math.max(d,a)),"undefined"!==typeof f&&(a=Math.min(f,a)),a):"undefined"!==typeof d&&a<d||"undefined"!==typeof f&&a>f?this.chancy(b,c+1):a}chancyMin(a){const {constructor:b}=Object.getPrototypeOf(this);return b.chancyMin(a)}chancyMax(a){const {constructor:b}=
Object.getPrototypeOf(this);return b.chancyMax(a)}static chancyMin(a){var b,c,d,f,h,l,q;if(Array.isArray(a)){for(const r of a)if(!n(r))throw Error("Cannot pass non-numbers to chancyMin array input");return Math.min(...a)}if("string"===typeof a)return this.diceMin(a);if("number"===typeof a)return a;if("object"===typeof a){a.type=null!==(b=a.type)&&void 0!==b?b:"random";"random"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==typeof a.max||(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "dice":return this.diceMin(a.dice);
case "normal":return null!==(c=a.min)&&void 0!==c?c:Number.NEGATIVE_INFINITY;case "normal_integer":return null!==(d=a.min)&&void 0!==d?d:Number.NEGATIVE_INFINITY;case "integer":return null!==(f=a.min)&&void 0!==f?f:0;case "random":return null!==(h=a.min)&&void 0!==h?h:0;case "boxMuller":return Number.NEGATIVE_INFINITY;case "gaussian":return Number.NEGATIVE_INFINITY;case "irwinHall":return 0;case "bates":return 0;case "batesgaussian":return Number.NEGATIVE_INFINITY;case "bernoulli":return 0;case "exponential":return 0;
case "pareto":return null!==(l=a.scale)&&void 0!==l?l:1;case "poisson":return 1;case "hypergeometric":const {N:r=50,K:t=10,n:u=5}=a;return Math.max(0,u+t-r);case "rademacher":return-1;case "binomial":return 0;case "betaBinomial":return 0;case "beta":return Number.EPSILON;case "gamma":return Number.EPSILON;case "studentsT":return Number.NEGATIVE_INFINITY;case "wignerSemicircle":return-1*(null!==(q=a.R)&&void 0!==q?q:10);case "kumaraswamy":return Number.EPSILON;case "hermite":return 0;case "chiSquared":return 0;
case "rayleigh":return 0;case "logNormal":return Number.EPSILON;case "cauchy":return Number.NEGATIVE_INFINITY;case "laplace":return Number.NEGATIVE_INFINITY;case "logistic":return Number.NEGATIVE_INFINITY}throw Error(`Invalid input type ${a.type}.`);}throw Error("Invalid input supplied to chancyMin");}static chancyMax(a){var b,c,d,f,h,l,q,r,t;if(Array.isArray(a)){for(const u of a)if(!n(u))throw Error("Cannot pass non-numbers to chancyMax array input");return Math.max(...a)}if("string"===typeof a)return this.diceMax(a);
if("number"===typeof a)return a;if("object"===typeof a){a.type=null!==(b=a.type)&&void 0!==b?b:"random";"random"!==a.type&&"integer"!==a.type||"undefined"===typeof a.min||"undefined"!==typeof a.max||(a.max=Number.MAX_SAFE_INTEGER);switch(a.type){case "dice":return this.diceMax(a.dice);case "normal":return null!==(c=a.max)&&void 0!==c?c:Number.POSITIVE_INFINITY;case "normal_integer":return null!==(d=a.max)&&void 0!==d?d:Number.POSITIVE_INFINITY;case "integer":return null!==(f=a.max)&&void 0!==f?f:
1;case "random":return null!==(h=a.max)&&void 0!==h?h:1;case "boxMuller":return Number.POSITIVE_INFINITY;case "gaussian":return Number.POSITIVE_INFINITY;case "irwinHall":return null!==(l=a.n)&&void 0!==l?l:6;case "bates":return 1;case "batesgaussian":return Number.POSITIVE_INFINITY;case "bernoulli":return 1;case "exponential":return Number.POSITIVE_INFINITY;case "pareto":return Number.POSITIVE_INFINITY;case "poisson":return Number.MAX_SAFE_INTEGER;case "hypergeometric":const {K:u=10,n:A=5}=a;return Math.min(A,
u);case "rademacher":return 1;case "binomial":return null!==(q=a.n)&&void 0!==q?q:1;case "betaBinomial":return null!==(r=a.n)&&void 0!==r?r:1;case "beta":return 1;case "gamma":return Number.POSITIVE_INFINITY;case "studentsT":return Number.POSITIVE_INFINITY;case "wignerSemicircle":return null!==(t=a.R)&&void 0!==t?t:10;case "kumaraswamy":return 1;case "hermite":return Number.MAX_SAFE_INTEGER;case "chiSquared":return Number.POSITIVE_INFINITY;case "rayleigh":return Number.POSITIVE_INFINITY;case "logNormal":return Number.POSITIVE_INFINITY;
case "cauchy":return Number.POSITIVE_INFINITY;case "laplace":return Number.POSITIVE_INFINITY;case "logistic":return Number.POSITIVE_INFINITY}throw Error(`Invalid input type ${a.type}.`);}throw Error("Invalid input supplied to chancyMax");}choice(a){return this.weightedChoice(a)}weights(a){const b=new Map;a.forEach(function(c){let d=0;b.has(c)&&(d=b.get(c));b.set(c,d+1)});return b}weightedChoice(a){let b=0;if(Array.isArray(a)){if(0===a.length)return null;if(1===a.length)return a[0];a=this.weights(a);
var c=this.weightedChoice(a);a.clear();return c}if(a instanceof Map){if(0===a.size)return null;if(1===a.size)return a.keys().next().value;a.forEach(h=>{b+=h})}else{var d=Object.keys(a);if(0===d.length)return null;if(1===d.length)return d[0];for(c in a){if(0>a[c])throw Error("Probability cannot be negative");b+=a[c]}}d=this._random()*b;let f=0;if(a instanceof Map)for(const [h,l]of a){if(f+=l,d<f)return h}else for(c in a)if(f+=a[c],d<f)break;return c}pool(a){return new Z(a,this)}static parseDiceArgs(a=
1,b=6,c=0){if(null===a||"undefined"===typeof a||0>=arguments.length)throw Error("Dice expects at least one argument");if("string"===typeof a)return this.parseDiceString(a);if("object"===typeof a)if(Array.isArray(a))[a,b,c]=a;else{if("undefined"===typeof a.n&&"undefined"===typeof a.d&&"undefined"===typeof a.plus)throw Error("Invalid input given to dice related function - dice object must have at least one of n, d or plus properties.");({n:a=1,d:b=6,plus:c=0}=a)}e({n:a}).int(`Expected n to be an integer, got ${a}`);
e({d:b}).int(`Expected d to be an integer, got ${b}`);return{n:a,d:b,plus:c}}parseDiceArgs(a=1,b=6,c=0){const {constructor:d}=Object.getPrototypeOf(this);return d.parseDiceArgs(a,b,c)}static parseDiceString(a){if(!x[a]){var b=a.replace(/ +/g,"");if(/^[+-]*[\d.]+$/.test(b))return{n:0,d:0,plus:parseFloat(b)};U.test(a)&&(b=U.exec(b),null!==b&&(x[a]={n:parseInt(b[1]),d:parseInt(b[2]),plus:parseFloat(b[3])},Number.isNaN(x[a].n)&&(x[a].n=1),Number.isNaN(x[a].d)&&(x[a].d=6),Number.isNaN(x[a].plus)&&(x[a].plus=
0)));if("undefined"===typeof x[a])throw Error(`Could not parse dice string ${a}`);}return x[a]}diceMax(a,b,c){const {constructor:d}=Object.getPrototypeOf(this);return d.diceMax(a,b,c)}diceMin(a,b,c){const {constructor:d}=Object.getPrototypeOf(this);return d.diceMin(a,b,c)}static diceMax(a=1,b=6,c=0){({n:a,d:b,plus:c}=this.parseDiceArgs(a,b,c));return a*b+c}static diceMin(a=1,b=6,c=0){({n:a,d:b,plus:c}=this.parseDiceArgs(a,b,c));return a+c}diceExpanded(a=1,b=6,c=0){({n:a,d:b,plus:c}=this.parseDiceArgs(a,
b,c));if("number"===typeof a){let d=a;const f=Math.max(b,0);if(1===b)return{dice:Array(a).fill(b),plus:c,total:a*b+c};if(0===a||0===b)return{dice:[],plus:c,total:c};a=0>d?-1:1;d*=a;for(b={dice:[],plus:c,total:c};0<d;)b.dice.push(a*this.randInt(1,f)),d--;b.total=m(b.dice)+c;return b}throw Error("Invalid arguments given to dice");}dice(a,b,c){return this.diceExpanded(a,b,c).total}parseDiceString(a){const {constructor:b}=Object.getPrototypeOf(this);return b.parseDiceString(a)}clamp(a,b,c){"undefined"!==
typeof c&&(a=a<=c?a:c);"undefined"!==typeof b&&(a=a>=b?a:b);return a}bin(a,b,c,d){e({val:a}).gt(c).lt(d);d-=c;return Math.round((a-c)/d*(b-1))/(b-1)*d+c}}var F=new WeakMap;var D=new WeakMap;var G=new WeakMap;var da=new WeakMap;O.version="0.2.1";class E extends O{static predictable(a){return new this(null!==a&&void 0!==a?a:5789938451)}serialize(){return{seed:this.getSeed(),version:"0.2.1"}}sameAs(a){return a instanceof E?this.getRandomSource()===a.getRandomSource()&&this.getSeed()===a.getSeed():!1}from(a){this.setSeed(a.getSeed());
return this}_next(){this.setSeed(this.getSeed()+2654435769|0);let a=this.getSeed();a=Math.imul(a^a>>>16,569420461);a=Math.imul(a^a>>>15,1935289751);return((a^a>>>15)>>>0)/4294967296}rotCompatible(){const a=this;return{getUniform(){return a.random()},getUniformInt(b,c){return a.randInt(b,c)},getNormal(b=0,c=1){return a.boxMuller({mean:b,stddev:c})},getPercentage(){return 1+Math.floor(100*this.getUniform())},getItem(b){return b.length?b[Math.floor(this.getUniform()*b.length)]:null},shuffle(b){const c=
[];for(b=b.slice();b.length;){const d=b.indexOf(this.getItem(b));c.push(b.splice(d,1)[0])}return c},getWeightedValue(b){return a.weightedChoice(b)},getSeed(){return a.getSeed()},setSeed(b){a.setSeed(b);return this},getState(){return a.serialize()},setState(b){a.setSeed(b.seed);return this},clone(){return(new E).rotCompatible().setState(this.getState())}}}}return E}();
